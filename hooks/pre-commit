#!/usr/bin/env bash
# Version: 0.0.1
# Attempt to always run the latest remote version of this hook.
# If update fails, fall back to the embedded/local implementation below.
REMOTE_URL="https://raw.githubusercontent.com/IldarMinaev/pre-commit-tests/refs/heads/main/hooks/pre-commit"
# Prevent recursion: when set, do not attempt remote update again.
if [ -z "$PRE_COMMIT_REMOTE_EXEC" ]; then
    TMPFILE=$(mktemp 2>/dev/null || mktemp -t pre-commit)
    DOWNLOAD_OK=0
    # Try curl, then wget
    if command -v curl >/dev/null 2>&1; then
        if curl -fsSL --max-time 10 "$REMOTE_URL" -o "$TMPFILE"; then
            DOWNLOAD_OK=1
        fi
    elif command -v wget >/dev/null 2>&1; then
        if wget -qO "$TMPFILE" "$REMOTE_URL"; then
            DOWNLOAD_OK=1
        fi
    fi
    if [ "$DOWNLOAD_OK" -eq 1 ]; then
        # Basic validation: must be non-empty and contain a shebang and known token
        if [ -s "$TMPFILE" ] && grep -E -q '^#!' "$TMPFILE" >/dev/null 2>&1 && grep -E -q 'hook-impl|pre-commit|pre_commit' "$TMPFILE" >/dev/null 2>&1; then
            chmod +x "$TMPFILE" || true
            # Determine local hook path (the file we're currently running)
            LOCAL_HOOK="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
            # If the downloaded file differs from the current hook, atomically replace it
            if [ -f "$LOCAL_HOOK" ]; then
                if ! cmp -s "$TMPFILE" "$LOCAL_HOOK"; then
                    # Attempt atomic replace. Keep a timestamped backup on failure.
                    BACKUP="${LOCAL_HOOK}.bak.$(date +%s)"
                    if mv "$LOCAL_HOOK" "$BACKUP" 2>/dev/null; then
                        if mv "$TMPFILE" "$LOCAL_HOOK" 2>/dev/null; then
                            chmod +x "$LOCAL_HOOK" || true
                            PRE_COMMIT_REMOTE_EXEC=1 exec "$LOCAL_HOOK" "$@"
                        else
                            # restore backup and exec downloaded directly
                            mv "$BACKUP" "$LOCAL_HOOK" 2>/dev/null || true
                            PRE_COMMIT_REMOTE_EXEC=1 exec "$TMPFILE" "$@"
                        fi
                    else
                        # Could not move local to backup (maybe different FS); try direct replace
                        if mv "$TMPFILE" "$LOCAL_HOOK" 2>/dev/null; then
                            chmod +x "$LOCAL_HOOK" || true
                            PRE_COMMIT_REMOTE_EXEC=1 exec "$LOCAL_HOOK" "$@"
                        else
                            # As a last resort exec downloaded file without replacing
                            PRE_COMMIT_REMOTE_EXEC=1 exec "$TMPFILE" "$@"
                        fi
                    fi
                else
                    # Files are identical: just exec the local hook to avoid unnecessary replaces
                    PRE_COMMIT_REMOTE_EXEC=1 exec "$LOCAL_HOOK" "$@"
                fi
            else
                # Local hook doesn't exist (unlikely) â€” install downloaded as local hook
                if mv "$TMPFILE" "$LOCAL_HOOK" 2>/dev/null; then
                    chmod +x "$LOCAL_HOOK" || true
                    PRE_COMMIT_REMOTE_EXEC=1 exec "$LOCAL_HOOK" "$@"
                else
                    PRE_COMMIT_REMOTE_EXEC=1 exec "$TMPFILE" "$@"
                fi
            fi
        fi
    fi
    # Cleanup temp file if still present and we didn't exec
    rm -f "$TMPFILE" 2>/dev/null || true
fi

# start templated
INSTALL_PYTHON=/usr/bin/python3
ARGS=(hook-impl --config=.pre-commit-config.yaml --hook-type=pre-commit --skip-on-missing-config)
# end templated

HERE="$(cd "$(dirname "$0")" && pwd)"
GIT_DIR=$(git rev-parse --git-dir 2>/dev/null || true)
if [ -n "$GIT_DIR" ]; then
    hooks_to_check=(applypatch-msg commit-msg fsmonitor-watchman post-update pre-applypatch pre-commit pre-merge-commit prepare-commit-msg pre-push pre-rebase pre-receive push-to-checkout sendemail-validate update)
    for hook in "${hooks_to_check[@]}"; do
        HOOK_PATH="$GIT_DIR/hooks/$hook"
        if [ -e "$HOOK_PATH" ] && [ -x "$HOOK_PATH" ]; then
            # If the hook doesn't look like a pre-commit framework hook, fail.
            if ! grep -E -q 'pre-commit|pre_commit|-mpre_commit|hook-impl' "$HOOK_PATH"; then
                echo "Local .git/hooks/$hook exists and is not the pre-commit framework hook. Aborting to avoid running conflicting hooks." 1>&2
                exit 1
            fi
        fi
    done
fi
ARGS+=(--hook-dir "$HERE" -- "$@")

if [ -x "$INSTALL_PYTHON" ]; then
    exec "$INSTALL_PYTHON" -mpre_commit "${ARGS[@]}"
elif command -v pre-commit > /dev/null; then
    exec pre-commit "${ARGS[@]}"
else
    echo '`pre-commit` not found.  Did you forget to activate your virtualenv?' 1>&2
    exit 1
fi
